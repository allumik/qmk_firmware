# QMK Breaking Changes - 2025 May 25 Changelog

## Notable Features

### Flow Tap ([#25125](https://github.com/qmk/qmk_firmware/pull/25125))

Adds Flow Tap as a core tap-hold option to disable HRMs during fast typing, aka Global Quick Tap, Require Prior Idle.

Flow Tap modifies mod-tap MT and layer-tap LT keys such that when pressed within a short timeout of the preceding key, the tapping behavior is triggered. It basically disables the hold behavior during fast typing, creating a "flow of taps." It also helps to reduce the input lag of tap-hold keys during fast typing, since the tapped behavior is sent immediately.

See the [Flow Tap documentation](../tap_hold#flow-tap) for more information.

### Community Modules `1.1.1` ([#25050](https://github.com/qmk/qmk_firmware/pull/25050), [#25187](https://github.com/qmk/qmk_firmware/pull/25187))

Version `1.1.1` introduces support for module defined RGB matrix effects and indicator callbacks, as well as pointing and layer state callbacks.

See the [Community Modules documentation](../features/community_modules) for more information, including the full list of available hooks.

## Changes Requiring User Action

### Updated Keyboard Codebases

| Old Keyboard Name      | New Keyboard Name    |
|------------------------|----------------------|
| chew                   | chew/split           |
| deemen17/de60fs        | deemen17/de60/r1     |
| keyten/kt60hs_t        | keyten/kt60hs_t/v1   |
| plywrks/ply8x          | plywrks/ply8x/solder |
| rookiebwoy/late9/rev1  | ivndbt/late9/rev1    |
| rookiebwoy/neopad/rev1 | ivndbt/neopad/rev1   |

## Deprecation Notices

In line with the [notice period](../support_deprecation_policy#how-much-advance-notice-will-be-given), deprecation notices for larger items are listed here.

### Deprecation of `qmk generate-compilation-database` ([#25237](https://github.com/qmk/qmk_firmware/pull/25237))

This command has been deprecated as it cannot take into account configurables such as [converters](/feature_converters) or environment variables normally specified on the command line; please use the `--compiledb` flag with `qmk compile` instead.

### Deprecation of `usb.force_nkro`/`FORCE_NKRO` ([#25262](https://github.com/qmk/qmk_firmware/pull/25262))

Unpicking the assumption that only USB can do NKRO, forcing of NKRO on every boot has been deprecated. As this setting persists, it produces unnecessary user confusion when the various NKRO keycodes (for example `NK_TOGG`) do not behave as expected.

The new defaults can be configured in the following ways:

:::::tabs

==== keyboard.json

```json [keyboard.json]
{
    "host": { // [!code focus]
        "default": { // [!code focus]
            "nkro": true // [!code focus]
        } // [!code focus]
    } // [!code focus]
}

```

==== keymap.json

```json [keymap.json]
{
    "config": {
        "host": { // [!code focus]
            "default": { // [!code focus]
                "nkro": true // [!code focus]
            } // [!code focus]
        } // [!code focus]
    }
}

```

==== config.h

```c [config.h]
#pragma once

#define NKRO_DEFAULT_ON true // [!code focus]
```

:::::

The deprecated options will be removed in a future breaking changes cycle.

### `CTPC`/`CONVERT_TO_PROTON_C` removal ([#25111](https://github.com/qmk/qmk_firmware/pull/25111))

Deprecated build options `CTPC` and `CONVERT_TO_PROTON_C` have been removed. Users should of these should migrate to `CONVERT_TO=proton_c`.

see the [Converters Feature](../feature_converters)  documentation for more information.

### `DEFAULT_FOLDER` removal ([#23281](https://github.com/qmk/qmk_firmware/pull/23281))

`DEFAULT_FOLDER` was originally introduced to work around limitations within the build system.
Parent folders containing common configuration would create invalid build targets.

With the introduction of [`keyboard.json`](./20240526#keyboard-json) as a configuration file, the build system now has a consistent method to detect build targets.
The `DEFAULT_FOLDER` functionality is now redundant and the intent is for `rules.mk` to become pure configuration.

Backwards compatibility of build targets has been maintained where possible.

### Converter `Pin Compatible` updates ([#20330](https://github.com/qmk/qmk_firmware/pull/20330))

Converter support has been further limited to only function if a keyboard declares that is is compatible.

This can be configured in the following ways:

:::::tabs

==== keyboard.json

```json [keyboard.json]
{
    "development_board": "promicro", // [!code focus]
}
```

==== rules.mk

```make [rules.mk]
PIN_COMPATIBLE = promicro
```

:::::

see the [Converters Feature](../feature_converters)  documentation for more information.

### Deprecation of `encoder_update_{kb|user}`

These callbacks are now considered end-of-life and will be removed over the next breaking changes cycle, ending August 2025. PRs containing these callbacks will be asked to change to use [encoder mapping](/features/encoders#encoder-map).

`ENCODER_MAP_ENABLE` will subsequently be changed to "default-on" when encoders are enabled, and future breaking changes cycles will remove this flag entirely.

To migrate usage of `encoder_update_user` to encoder map you'll need to define new keycodes:

```c
enum {
    MY_ENCODER_LEFT = QK_USER,
    MY_ENCODER_RIGHT,
};
```

...add the keycodes to a new encoder map (optionally with transparent layers above, if you want identical functionality of layer-independence):

```c
#if defined(ENCODER_MAP_ENABLE)
const uint16_t PROGMEM encoder_map[][NUM_ENCODERS][NUM_DIRECTIONS] = {
    [0] = { ENCODER_CCW_CW(MY_ENCODER_LEFT, MY_ENCODER_RIGHT) },
    [1] = { ENCODER_CCW_CW(KC_TRNS, KC_TRNS) },
    [2] = { ENCODER_CCW_CW(KC_TRNS, KC_TRNS) },
    [3] = { ENCODER_CCW_CW(KC_TRNS, KC_TRNS) },
};
#endif
```

...and handle the new keycodes within `process_record_user`, much like any other keycode in your keymap:

```c
bool process_record_user(uint16_t keycode, keyrecord_t *record) {
  switch (keycode) {
    case MY_ENCODER_LEFT:
      if (record->event.pressed) {
        // Do something when rotated left
      }
      return false; // Skip all further processing of this key
    case MY_ENCODER_RIGHT:
      if (record->event.pressed) {
        // Do something when rotated right
      }
      return false; // Skip all further processing of this key
  }
}
```

If your board has multiple encoders, each encoder will need its own pair of keycodes defined as per above.

## Full changelist
